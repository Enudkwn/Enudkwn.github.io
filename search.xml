<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL面试题</title>
    <url>/2025/03/06/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>(总结于<a href="https://xiaolincoding.com/interview/mysql.html">小林coding</a>，缩减了部分内容，仅供学习参考，正在更新中)</p>
<h1 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h1><h2 id="NOSQL和SQL的区别"><a href="#NOSQL和SQL的区别" class="headerlink" title="NOSQL和SQL的区别"></a>NOSQL和SQL的区别</h2><p><strong>SQL</strong>数据库，指关系型数据库，主要代表：SQL Server、Oracle、MySQL(开源)、PostgreSQL(开源)</p>
<p>关系型数据库存储结构化数据，这些数据逻辑上以行列二维表格的形式存在，每一列代表数据的一个属性，每一行代表一个数据实体</p>
<p><strong>NoSQL</strong>指非关系型数据库，主要代表：MongoDB、Redis</p>
<p>NoSQL数据库逻辑上提供了不同于二维表的存储方式，存储方式可以使JSON文档、哈希表或者其他</p>
<p>选择SQL还是NoSQL,考虑一下因素：</p>
<p><strong>ACID vs BASE</strong></p>
<p>关系型数据库支持ACID，即原子性、一致性、隔离性、持久性；相对而言，NoSQL采用更加宽松的模型BASE，即基本可用、软状态、最终一致性</p>
<p>从实用的角度出发，我们需要考虑对于面对的应用场景，ACID是否是必须的。</p>
<p>比如银行应用就必须保证 ACID，否则一笔钱可能被使用两次；<br>又比如社交软件不必保证ACID，因为一条状态的更新对于所有用户读取先后时间有数秒不同并不影响使用</p>
<p>对于需要保证ACID的应用，我们可以优先考虑SQL。反之则可以优先考虑NoSQL</p>
<p><strong>扩展性对比</strong></p>
<p>NoSQL数据之间无关系，这样就非常容易扩展，也无形之间，在架构的层面上带来了可扩展的能力。比如 redis 自带主从复制模式、 哨兵模式、切片集群模式.</p>
<p>相反关系型数据库的数据之间存在关联性，水平扩展较难，需要解决跨服务器JOIN，分布式事务等问 题。</p>
]]></content>
      <categories>
        <category>MySQL面试题</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2025/03/08/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h2><ol>
<li>SQL语句可以单行或多行书写，以<strong>分号结尾</strong>。</li>
<li>SQL语句可以使用空格&#x2F;缩进来增强语句的可读性。</li>
<li>MySQL数据库的SQL语句不区分大小写，<strong>关键字</strong>建议使用大写。</li>
<li>注释：<ul>
<li>单行注释：–注释内容 或 #注释内容(MySQL特有)</li>
<li>多行注释：&#x2F;<em>注释内容</em>&#x2F;</li>
</ul>
</li>
</ol>
<h2 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL(数据定义语言)"></a>DDL(数据定义语言)</h2><ol>
<li>添加数据：INSERT INTO 表名 (字段1,字段2,…) VALUES (值1,值2,…)</li>
</ol>
<h2 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML(数据操作语言)"></a>DML(数据操作语言)</h2><h2 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL(数据查询语言)"></a>DQL(数据查询语言)</h2><h2 id="DCL-数据控制语言"><a href="#DCL-数据控制语言" class="headerlink" title="DCL(数据控制语言)"></a>DCL(数据控制语言)</h2>]]></content>
      <categories>
        <category>数据库基础</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>MySQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础面试题</title>
    <url>/2025/03/05/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>(总结于<a href="https://xiaolincoding.com/interview/java.html">小林coding</a>，缩减了部分内容，仅供学习参考，正在更新中)</p>
<h1 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h1><h2 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h2><ol>
<li><strong>平台无关性</strong>：Java编译器将源码编译为字节码，字节码可以在任何装有Java虚拟机的平台上运行，不需要重新编译。</li>
<li><strong>面向对象</strong>：Java是一门严格面向对象的语言，几乎一切都是对象。面向对象编程（OOP）特性使得代码更易于维护和重用。</li>
<li><strong>内存管理</strong>：Java有自己的垃圾回收机制，自动管理内存和不再使用的对象。开发者不用手动管理内存，减少了内存泄露和其他内存相关的问题。</li>
</ol>
<h2 id="Java为什么能跨平台"><a href="#Java为什么能跨平台" class="headerlink" title="Java为什么能跨平台"></a>Java为什么能跨平台</h2><p>这主要依赖于Java虚拟机（JVM），开发者编写的Java源代码经编译后得到.class文件，即字节码文件。Java虚拟机可以将字节码翻译为特定平台下的机器码。</p>
<p>所以运行Java程序必须要有JVM支持，即使将Java程序打包为可执行文件（例如.exe），它也需要JVM的支持。</p>
<p>跨平台的是Java程序，而JVM是用C&#x2F;C++编写的，不可跨平台，不同平台需要安装适合的JVM。</p>
<h2 id="JVM-JRE-JDK的关系"><a href="#JVM-JRE-JDK的关系" class="headerlink" title="JVM,JRE,JDK的关系"></a>JVM,JRE,JDK的关系</h2><ul>
<li><strong>JVM</strong>：略</li>
<li><strong>JDK</strong>是Java开发工具包，包含了JVM，编译器，调试器等开发工具，以及一系列的类库（如Java标准库和开发工具库）。即JDK提供了开发、编译、调试和运行Java程序的所需的全部工具和环境。</li>
<li><strong>JRE</strong>是Java运行时环境，是Java程序运行的最小环境，包含了JVM和Java标准库。JRE不包含开发工具，只包含运行Java程序所需的最小环境。</li>
</ul>
<h2 id="为什么Java解释和编译都有"><a href="#为什么Java解释和编译都有" class="headerlink" title="为什么Java解释和编译都有"></a>为什么Java解释和编译都有</h2><ul>
<li><strong>解释性</strong>：Java源代码被编译为字节码，JIT会把编译过的机器码保存下来下次使用。</li>
<li><strong>编译性</strong>：JVM中有方法调用计数器，当调用次数达到一定阈值时，JVM会使用JIT编译字节码为机器码，下次再调用时直接执行机器码，提高性能。否则就是用解释器进行解释执行。</li>
</ul>
<h2 id="编译型语言和解释型语言的区别"><a href="#编译型语言和解释型语言的区别" class="headerlink" title="编译型语言和解释型语言的区别"></a>编译型语言和解释型语言的区别</h2><ul>
<li><strong>编译型语言</strong>：编译型语言在编译时将源代码编译为目标代码（如机器码），然后再运行目标代码。编译型语言在编译时进行优化，提高性能，但跨平台性差。</li>
<li><strong>解释型语言</strong>：解释型语言在运行时解释执行源代码，无需编译为目标代码。解释型语言在运行时进行优化，跨平台性好，但性能较低。</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="八种基本的数据类型"><a href="#八种基本的数据类型" class="headerlink" title="八种基本的数据类型"></a>八种基本的数据类型</h2><p>Java支持的数据类分为两类：基本数据类型和引用数据类型</p>
<p>基本数据类型有8中，可分为3类：</p>
<ul>
<li>数值型：整数型（byte，short，int，long），浮点型（float，double）</li>
<li>字符型：char</li>
<li>布尔型：boolean</li>
</ul>
<p>引用数据类型有：类、接口、数组…</p>
<ul>
<li>注意：<ol>
<li>1字节（byte,boolean），2字节（short,char），4字节（int，float），8字节（long，double）</li>
<li>浮点数的默认值为double，若需要float，需在末尾加上f或F。</li>
<li>整型默认为int，若需要byte，short，long，需在末尾加上b、s、l。</li>
<li>八种数据类型的包装类：除了char-&gt;Character、int-&gt;Integer，其他都是基本数据类型首字母大写。</li>
<li>char类型是无符号的，不能为负，所以0开头</li>
</ol>
</li>
</ul>
<h2 id="int和long之间的转换"><a href="#int和long之间的转换" class="headerlink" title="int和long之间的转换"></a>int和long之间的转换</h2><ul>
<li><strong>int转long</strong>：long数据类型的范围比int大，因此long转int是安全的，可通过直接赋值和强制类型转换实现。</li>
<li><strong>long转int</strong>：long转为int可能会出现数据丢失或溢出的问题，若转换的数据超出int类型的范围，转换的结果是阶段后低位部分。</li>
</ul>
<h2 id="数据类型转换方式"><a href="#数据类型转换方式" class="headerlink" title="数据类型转换方式"></a>数据类型转换方式</h2><ul>
<li><strong>自动类型转换(隐式转换)</strong>：目标类型范围大于源类型时，Java会自动将源类型转换为目标类型</li>
<li><strong>强制类型转换(显式转换)</strong>：目标类型范围小于源类型时，需要使用强制类型转换，这可能导致数据丢失或溢出</li>
<li><strong>字符串转换</strong>：Java提供了将字符串转换为其他数据类型的方法，如Integer.parseInt()、Double.parseDouble()等</li>
<li><strong>数值之间转换</strong>：Java提供了将数值转换为其他数据类型的方法，如Integer.valueOf()、Double.valueOf()等</li>
</ul>
<h2 id="类型互换可能会出现那些问题"><a href="#类型互换可能会出现那些问题" class="headerlink" title="类型互换可能会出现那些问题"></a>类型互换可能会出现那些问题</h2><ul>
<li><strong>数据丢失</strong>：如果目标类型范围小于源类型范围，可能会出现数据丢失的情况</li>
<li><strong>数据溢出</strong>：如果目标类型范围大于源类型范围，可能会出现数据溢出的情况，转换的结果会额外填充高位部分，但源石数据爆粗不变</li>
<li><strong>精度损失</strong>：在进行浮点类型的转换时，可能发生精度损失</li>
<li><strong>类型不匹配</strong>：在进行类型转换时，需要确保源类型和目标类型是兼容的</li>
</ul>
<h2 id="为什么使用BigDecimal不用Double"><a href="#为什么使用BigDecimal不用Double" class="headerlink" title="为什么使用BigDecimal不用Double"></a>为什么使用BigDecimal不用Double</h2><p>double会出现精度丢失的问题，double执行的是二进制浮点运算，二进制在有些情况不能准确表示小数，就像十进制不能准确表示1&#x2F;3，也就是说二进制表示小数只能表示(1&#x2F;2)^n的任意组合</p>
<p>这就会导致可能出现0.6无法购买0.5和0.1的商品</p>
<p>而BigDecimal是使用字符串表示的，可以进行精确计算</p>
<h2 id="装箱和拆箱是什么"><a href="#装箱和拆箱是什么" class="headerlink" title="装箱和拆箱是什么"></a>装箱和拆箱是什么</h2><p>装箱(boxing)和拆箱(unboxing)是指将基本数据类型和对应的包装类之间进行转换的过程</p>
<p>赋值时，Java1.5以后，所有的装箱和拆箱都是有编译器完成，进行自动装箱和拆箱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>
<p>方法调用时，可以直接传入原始数据或对象，编译器同样会进行转换</p>
<p><strong>自动装箱的弊端</strong></p>
<p>在一个循环中进行自动装箱，会产生多于的对象影响程序的性能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123; sum+=i; &#125;</span><br></pre></td></tr></table></figure>
<p>sum + i 中的 + 不适用于Integer对象，程序运行时会先将sum自动拆箱，再进行数值相加的操作，然后再进行自动装箱的操作转换为Integer对象，类似于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sum.intValue() + i;<span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(result);</span><br></pre></td></tr></table></figure>
<p>故会在循环中产生大量无用的Integer对象，降低了程序的性能、加重了垃圾回收的工作量</p>
<h2 id="Java为什么需要Integer"><a href="#Java为什么需要Integer" class="headerlink" title="Java为什么需要Integer"></a>Java为什么需要Integer</h2><p>将int类型包装为Integer对象好处很多，可以把属性(也就是数据)和处理数据的方法结合在一起，例如parseInt()方法</p>
<p>还有个重要原因就是Java中绝大部分方法或类都是用来处理类类型对象的，例如ArrayList集合类只能以类作为它的存储对象</p>
<p><strong>泛型中的应用</strong>：在Java中泛型只能使用引用类型</p>
<p><strong>转换中的应用</strong>：Java中基本数据类型和引用类型不能直接进行转换，必须通过包装类实现</p>
<p><strong>集合中的应用</strong>：在Java中集合类中的泛型只能是引用类型，不能是基本数据类型</p>
<h2 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h2><ul>
<li><p><strong>基本数据类型和引用类型</strong>：int是基本数据类型，不需要实例化，不用额外分配内存；Integer是引用类型，对象的引用和对象是分开存储的</p>
</li>
<li><p><strong>自动装箱拆箱</strong>：略</p>
</li>
<li><p><strong>空指针异常</strong>：Integer对象可以表示null，int不能表示null。对被赋予null值的Integer对象进行操作会出现空指针异常</p>
</li>
</ul>
<h2 id="Integer缓存"><a href="#Integer缓存" class="headerlink" title="Integer缓存"></a>Integer缓存</h2><p>Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象</p>
<p>默认情况下，这个范围为-128至127，即在-128至127之间的整数值，都会被缓存在静态缓存池中，避免每次创建新的Integer对象，提高性能。可通过Integer.valueOf()方法来获取缓存池中的Integer对象，如果缓存池中不存在对应的Integer对象，则创建一个新的对象并放入缓存池中。</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="如何理解面向对象，简单说说封装继承多态"><a href="#如何理解面向对象，简单说说封装继承多态" class="headerlink" title="如何理解面向对象，简单说说封装继承多态"></a>如何理解面向对象，简单说说封装继承多态</h2><p>面向对象是一种编程范式，它将现实中的事物抽象为对象，对象具有属性和方法。面向对象的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化</p>
<p>Java面向对象的三大特性：<strong>封装、继承、多态</strong>：</p>
<ul>
<li><strong>封装</strong>：封装是指将对象的属性和方法结合在一起，对外隐藏内部的细节，仅通过对象提供的接口与外界交互。增强了安全性并简化编程，使对象更加独立</li>
<li><strong>继承</strong>：继承是指子类可以继承父类的属性和方法，从而实现代码的重用。子类可以扩展父类的功能，也可以覆盖父类的方法，从而实现代码的复用。</li>
<li><strong>多态</strong>：多态是指一个对象在不同的情况下具有不同的行为，即对象的行为可以根据对象的状态或者类型而发生变化。多态性可分为编译时多态(重载)和运行时多态(重写)。多态使得对象的行为更加灵活和可扩展，从而提高程序的可维护性。</li>
</ul>
<p>多态表现于：</p>
<ul>
<li>方法重载：<ul>
<li>方法重载是指在同一个类中定义多个同名方法，但参数列表不同(参数类型、个数、顺序)，编译时根据参数列表选择对应的方法进行调用。</li>
<li>示例：对于一个 add 方法，可以定义为 add(int a, int b) 和 add(double a, double b)</li>
</ul>
</li>
<li>方法重写：<ul>
<li>方法重写是指子类重写父类的方法，使得子类具有父类方法的功能，但可以扩展或修改父类方法的实现。在运行时，JVM会根据对象的实际类型来决定调用哪个方法。</li>
<li>示例：对于一个 Animal 类，可以定义一个 eat 方法，子类 Cat 和 Dog 都可以重写这个方法，使得 Cat 和 Dog 的 eat 方法具有不同的实现。</li>
</ul>
</li>
<li>接口与实现：<ul>
<li>多个类可以实现同一个接口，并且用接口类型的引用来调用这些类的方法。这使得程序在面对不同的实现时，保持。一贯的调用方式</li>
<li>示例：定义一个接口 Animal，包含一个 eat 方法，然后定义两个实现类 Cat 和 Dog，实现 Animal 接口，使得 Cat 和 Dog 具有 eat 方法。</li>
</ul>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
